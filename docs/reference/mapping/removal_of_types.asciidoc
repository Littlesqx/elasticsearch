[[removal-of-types]]
== 映射类型的移除

IMPORTANT: 在 Elasticsearch 6.0.0 或更新的版本中被创建的索引将只包含一个<<mapping-type,映射类型>>。
在 5.x 被创建的多映射类型在 6.x 会继续像以前一样运作。而在 7.0.0 ，映射类型将会被完全移除。

[float]
=== 什么是映射类型？

自从 ElasticSearch 第一次发布以来，每个文档被存到一个索引，并且被分配一个映射类型。
映射类型用于表示文档或被索引的实体的类型，例如， `Twitter` 索引可能具有 `user` 类型和 `tweet` 类型。

每个索引类型都含有自己的字段，例如， `user` 类型可能会有 `full_name` 字段、 `user_name` 字段和 `email` 字段，而 `tweet` 类型可能有 `content` 字段、 `tweeted_at` 字段和类似 `user` 类型的 `user_name` 字段。

每个文档都有一个元字段 `_type` ，它包含类型的名称。通过在 URL 指定类型名称，搜索可以被限定为一种或多种类型：

[source,js]
----
GET twitter/user,tweet/_search
{
  "query": {
    "match": {
      "user_name": "kimchy"
    }
  }
}
----
// NOTCONSOLE

`type` 字段和文档的 `_id` 字段组合后生成 `_uid` 字段，所以不同类型但有着相同 `_id` 的文档是可以存在同一个索引的。

映射类型也可以用于建立文档间的<<mapping-parent-field,父子关系>>，例如文档类型 `question` 可以是文档类型 `answer` 的父类型。

[float]
=== 为什么映射类型会被移除？

最初，我们说 "index" 类似于 SQL 数据库的 "database" ，而 "type" 类似于 "table" 。

这是一个不好的类比，因为它导致了不正确的假设。在 SQL 数据库中，表格之间是相互独立的。一个表格的列与另一个表格中具有相同名称的列是没有关系的。但在映射类型中并非如此。

对于 ElasticSearch 的索引，不同映射类型中名称相同的字段在内部由相同的 Lucene 字段支持。也就是说，如果使用上面的例子， `user` 类型的 `user_name` 字段存储在与 `tweet` 类型的 `user_name` 字段相同的字段，并且两个 `user_name` 字段在两种类型里都必须具有相同的映射定义。

这会导致失败的场景，比如，在某一个类型里，你想把 `deleted` 设为 `date` 字段，而在同索引的另一个类型里设为 `boolean` 字段。
最重要的是，在同一索引中存储具有少量或不具有共有字段的不同实体会导致数据稀疏，并干扰 Lucene 有效压缩文档的能力。

由于这些原因，我们决定从 Elasticsearch 中移除映射类型。

[float]
=== 映射类型的替代方案

[float]
==== 索引每个文档类型

第一种替代方案是索引每个文档类型。
不要将 `tweents` 和 `users` 存储在单个 `twitter` 索引中，而是将 tweets 存储在 `tweets` 索引中， users 存储在 `user` 索引中。
索引是完全互相独立的，所以索引间的字段类型不会发生冲突。

这个方案有两个好处：

 * 数据更可能地密集，这将受益于 Lucene 的压缩技术。

 * 由于同一索引所有文档都代表单一实体，全文搜索中用于计分的统计项将更可能地准确。

每个索引的大小可以根据文档数量适当调整：对于 `user` 索引，你可以使用较小数量的主分片，而对于 `tweets` 索引，可以使用较大数量的主分片。

[float]
==== 自定义类型字段

当然，集群中主分片的数量应该是有限制的，因此你不能浪费将一个完整的分片用于收集仅仅几千个文档。
在这种情况下，你可以实现自定义的继续像旧 `_type` 字段工作的 `type` 字段。

让我们以前面的 `user`/`tweet` 为例。通常，工作的时候会遇到这样的情况：

[source,js]
----
PUT twitter
{
  "mappings": {
    "user": {
      "properties": {
        "name": { "type": "text" },
        "user_name": { "type": "keyword" },
        "email": { "type": "keyword" }
      }
    },
    "tweet": {
      "properties": {
        "content": { "type": "text" },
        "user_name": { "type": "keyword" },
        "tweeted_at": { "type": "date" }
      }
    }
  }
}

PUT twitter/user/kimchy
{
  "name": "Shay Banon",
  "user_name": "kimchy",
  "email": "shay@kimchy.com"
}

PUT twitter/tweet/1
{
  "user_name": "kimchy",
  "tweeted_at": "2017-10-24T09:00:00Z",
  "content": "Types are going away"
}

GET twitter/tweet/_search
{
  "query": {
    "match": {
      "user_name": "kimchy"
    }
  }
}
----
// NOTCONSOLE

你可以通过添加自定义类型字段来实现相同的功能，如下所示：

[source,js]
----
PUT twitter
{
  "mappings": {
    "_doc": {
      "properties": {
        "type": { "type": "keyword" }, <1>
        "name": { "type": "text" },
        "user_name": { "type": "keyword" },
        "email": { "type": "keyword" },
        "content": { "type": "text" },
        "tweeted_at": { "type": "date" }
      }
    }
  }
}

PUT twitter/_doc/user-kimchy
{
  "type": "user", <1>
  "name": "Shay Banon",
  "user_name": "kimchy",
  "email": "shay@kimchy.com"
}

PUT twitter/_doc/tweet-1
{
  "type": "tweet", <1>
  "user_name": "kimchy",
  "tweeted_at": "2017-10-24T09:00:00Z",
  "content": "Types are going away"
}

GET twitter/_search
{
  "query": {
    "bool": {
      "must": {
        "match": {
          "user_name": "kimchy"
        }
      },
      "filter": {
        "match": {
          "type": "tweet" <1>
        }
      }
    }
  }
}
----
// NOTCONSOLE
<1> 显式 `type` 字段代替隐式 `_type` 字段。

[float]
==== 没有映射类型的 Parent/Child

以前，父子关系的表示是通过设置一个映射类型为父亲，而另外的一个或多个映射类型为孩子。
没有了映射类型，我们不能再使用这种语法了。parent-child 功能会继续工作，
但实现文档之间关系的方式已更改为使用新的 <<parent-join,`join` 字段>>。


[float]
=== 移除映射类型的时间表

对于我们的用户，这是一个巨大的变动，所以我们努力让过程尽可能无痛度过。
变动将会如下地展开：

Elasticsearch 5.6.0::

* 为一个索引设置 `index.mapping.single_type: true` 以启用单一类型索引的行为在 6.0 将变为强制性。

* 代替 parent-child 的 <<parent-join,`join` 字段>> 在 5.6 版本被创建的索引可用。

Elasticsearch 6.x::

* 在 5.x 版本中被创建的索引，在 6.x 中会继续像在 5.x 中一样工作。

* 在 6.x 被创建的索引仅仅允许一个索引存在单一类型。 可以用任何名称命名类型，但只能有一个类型。
  首选的类型名称是 `_doc` ，所以索引 APIs 会具有与 7.0 相同的路径： `PUT {index}/_doc/{id}` and `POST {index}/_doc` 。

* `_type` 字段不再与 `_id` 字段结合生成 `_uid` 字段。 `_uid` 字段成为了 `_id` 字段的别名。

* 新的索引不再支持 parent/child 的旧语法，而应该用 <<parent-join,`join` 字段>>替换。

* `_default_` 映射类型被弃用。

Elasticsearch 7.x::

* `type` 参数在 URLs 中是可选的。例如索引一个文档不再需要该文档的 `type` 。新索引 APIs 在显示 id 的情况下是 `PUT {index}/_doc/{id}` ，而对于自动生成 ids 将是 `POST {index}/_doc` 。

* `GET|PUT _mapping` APIs 支持一个查询参数（`include_type_name`），该参数指定 body 是否包含类型名称的层级。
  默认值为 `true`。在 7.x 中，没有明确类型的索引会使用一个假的类型名称 `_doc` 。

* `_default_` 映射类型被移除。

Elasticsearch 8.x::

* `type` 参数在 URLs 中不再被支持。

* `include_type_name` 参数默认值为 `false`。

Elasticsearch 9.x::

* `include_type_name` 参数被移除。

[float]
=== Migrating multi-type indices to single-type

The <<docs-reindex,Reindex API>> can be used to convert multi-type indices to
single-type indices. The following examples can be used in Elasticsearch 5.6
or Elasticsearch 6.x.  In 6.x, there is no need to specify
`index.mapping.single_type` as that is the default.

[float]
==== Index per document type

This first example splits our `twitter` index into a `tweets` index and a
`users` index:

[source,js]
----
PUT users
{
  "settings": {
    "index.mapping.single_type": true
  },
  "mappings": {
    "_doc": {
      "properties": {
        "name": {
          "type": "text"
        },
        "user_name": {
          "type": "keyword"
        },
        "email": {
          "type": "keyword"
        }
      }
    }
  }
}

PUT tweets
{
  "settings": {
    "index.mapping.single_type": true
  },
  "mappings": {
    "_doc": {
      "properties": {
        "content": {
          "type": "text"
        },
        "user_name": {
          "type": "keyword"
        },
        "tweeted_at": {
          "type": "date"
        }
      }
    }
  }
}

POST _reindex
{
  "source": {
    "index": "twitter",
    "type": "user"
  },
  "dest": {
    "index": "users"
  }
}

POST _reindex
{
  "source": {
    "index": "twitter",
    "type": "tweet"
  },
  "dest": {
    "index": "tweets"
  }
}
----
// NOTCONSOLE

[float]
==== Custom type field

This next example adds a custom `type` field and sets it to the value of the
original `_type`.  It also adds the type to the `_id` in case there are any
documents of different types which have conflicting IDs:

[source,js]
----
PUT new_twitter
{
  "mappings": {
    "_doc": {
      "properties": {
        "type": {
          "type": "keyword"
        },
        "name": {
          "type": "text"
        },
        "user_name": {
          "type": "keyword"
        },
        "email": {
          "type": "keyword"
        },
        "content": {
          "type": "text"
        },
        "tweeted_at": {
          "type": "date"
        }
      }
    }
  }
}


POST _reindex
{
  "source": {
    "index": "twitter"
  },
  "dest": {
    "index": "new_twitter"
  },
  "script": {
    "source": """
      ctx._source.type = ctx._type;
      ctx._id = ctx._type + '-' + ctx._id;
      ctx._type = '_doc';
    """
  }
}
----
// NOTCONSOLE

