[[removal-of-types]]
== 映射类型的移除

IMPORTANT: 在 Elasticsearch 6.0.0 或更新的版本中被创建的索引将只包含一个<<mapping-type,映射类型>>。
在 5.x 被创建的多映射类型在 6.x 会继续像以前一样运作。而在 7.0.0 ，映射类型将会被完全移除。

[float]
=== 什么是映射类型？

自从 ElasticSearch 第一次发布以来，每个文档被存到一个索引，并且被分配一个映射类型。
映射类型用于表示文档或被索引的实体的类型，例如， `Twitter` 索引可能具有 `user` 类型和 `tweet` 类型。

每个索引类型都含有自己的字段，例如， `user` 类型可能会有 `full_name` 字段、 `user_name` 字段和 `email` 字段，而 `tweet` 类型可能有 `content` 字段、 `tweeted_at` 字段和类似 `user` 类型的 `user_name` 字段。

每个文档都有一个元字段 `_type` ，它包含类型的名称。通过在 URL 指定类型名称，搜索可以被限定为一种或多种类型：

[source,js]
----
GET twitter/user,tweet/_search
{
  "query": {
    "match": {
      "user_name": "kimchy"
    }
  }
}
----
// NOTCONSOLE

`type` 字段和文档的 `_id` 字段组合后生成 `_uid` 字段，所以不同类型但有着相同 `_id` 的文档是可以存在同一个索引的。

映射类型也可以用于建立文档间的<<mapping-parent-field,父子关系>>，例如文档类型 `question` 可以是文档类型 `answer` 的父类型。

[float]
=== 为什么映射类型会被移除？

最初，我们说 "index" 类似于 SQL 数据库的 "database" ，而 "type" 类似于 "table" 。

这是一个不好的类比，因为它导致了不正确的假设。在 SQL 数据库中，表格之间是相互独立的。一个表格的列与另一个表格中具有相同名称的列是没有关系的。但在映射类型中并非如此。

对于 ElasticSearch 的索引，不同映射类型中名称相同的字段在内部由相同的 Lucene 字段支持。也就是说，如果使用上面的例子， `user` 类型的 `user_name` 字段存储在与 `tweet` 类型的 `user_name` 字段相同的字段，并且两个 `user_name` 字段在两种类型里都必须具有相同的映射定义。

这会导致失败的场景，比如，在某一个类型里，你想把 `deleted` 设为 `date` 字段，而在同索引的另一个类型里设为 `boolean` 字段。
最重要的是，在同一索引中存储具有少量或不具有共有字段的不同实体会导致数据稀疏，并干扰 Lucene 有效压缩文档的能力。

由于这些原因，我们决定从 Elasticsearch 中移除映射类型。

[float]
=== Alternatives to mapping types

[float]
==== Index per document type

The first alternative is to have an index per document type.  Instead of
storing tweets and users in a single `twitter` index, you could store tweets
in the `tweets` index and users in the `user` index. Indices are completely
independent of each other and so there will be no conflict of field types
between indices.

This approach has two benefits:

* Data is more likely to be dense and so benefit from compression techniques
  used in Lucene.

* The term statistics used for scoring in full text search are more likely to
  be accurate because all documents in the same index represent a single
  entity.

Each index can be sized appropriately for the number of documents it will
contain: you can use a smaller number of primary shards for `users` and a
larger number of primary shards for `tweets`.

[float]
==== Custom type field

Of course, there is a limit to how many primary shards can exist in a cluster
so you may not want to waste an entire shard for a collection of only a few
thousand documents.  In this case, you can implement your own custom `type`
field which will work in a similar way to the old `_type`.

Let's take the `user`/`tweet` example above.  Originally, the workflow would
have looked something like this:

[source,js]
----
PUT twitter
{
  "mappings": {
    "user": {
      "properties": {
        "name": { "type": "text" },
        "user_name": { "type": "keyword" },
        "email": { "type": "keyword" }
      }
    },
    "tweet": {
      "properties": {
        "content": { "type": "text" },
        "user_name": { "type": "keyword" },
        "tweeted_at": { "type": "date" }
      }
    }
  }
}

PUT twitter/user/kimchy
{
  "name": "Shay Banon",
  "user_name": "kimchy",
  "email": "shay@kimchy.com"
}

PUT twitter/tweet/1
{
  "user_name": "kimchy",
  "tweeted_at": "2017-10-24T09:00:00Z",
  "content": "Types are going away"
}

GET twitter/tweet/_search
{
  "query": {
    "match": {
      "user_name": "kimchy"
    }
  }
}
----
// NOTCONSOLE

You could achieve the same thing by adding a custom `type` field as follows:

[source,js]
----
PUT twitter
{
  "mappings": {
    "_doc": {
      "properties": {
        "type": { "type": "keyword" }, <1>
        "name": { "type": "text" },
        "user_name": { "type": "keyword" },
        "email": { "type": "keyword" },
        "content": { "type": "text" },
        "tweeted_at": { "type": "date" }
      }
    }
  }
}

PUT twitter/_doc/user-kimchy
{
  "type": "user", <1>
  "name": "Shay Banon",
  "user_name": "kimchy",
  "email": "shay@kimchy.com"
}

PUT twitter/_doc/tweet-1
{
  "type": "tweet", <1>
  "user_name": "kimchy",
  "tweeted_at": "2017-10-24T09:00:00Z",
  "content": "Types are going away"
}

GET twitter/_search
{
  "query": {
    "bool": {
      "must": {
        "match": {
          "user_name": "kimchy"
        }
      },
      "filter": {
        "match": {
          "type": "tweet" <1>
        }
      }
    }
  }
}
----
// NOTCONSOLE
<1> The explicit `type` field takes the place of the implicit `_type` field.

[float]
==== Parent/Child without mapping types

Previously, a parent-child relationship was represented by making one mapping
type the parent, and one or more other mapping types the children.  Without
types, we can no longer use this syntax.  The parent-child feature will
continue to function as before, except that the way of expressing the
relationship between documents has been changed to use the new
<<parent-join,`join` field>>.


[float]
=== Schedule for removal of mapping types

This is a big change for our users, so we have tried to make it as painless as
possible.  The change will roll out as follows:

Elasticsearch 5.6.0::

* Setting `index.mapping.single_type: true` on an index will enable the
  single-type-per-index behaviour which will be enforced in 6.0.

* The <<parent-join,`join` field>> replacement for parent-child is available
  on indices created in 5.6.

Elasticsearch 6.x::

* Indices created in 5.x will continue to function in 6.x as they did in 5.x.

* Indices created in 6.x only allow a single-type per index.  Any name
  can be used for the type, but there can be only one. The preferred type name
  is `_doc`, so that index APIs have the same path as they will have in 7.0:
  `PUT {index}/_doc/{id}` and `POST {index}/_doc`

* The `_type` name can no longer be combined with the `_id` to form the `_uid`
  field. The `_uid` field has become an alias for the `_id` field.

* New indices no longer support the old-style of parent/child and should
  use the <<parent-join,`join` field>> instead.

* The `_default_` mapping type is deprecated.

Elasticsearch 7.x::

* The `type` parameter in URLs are optional.  For instance, indexing
  a document no longer requires a document `type`.  The new index APIs
  are `PUT {index}/_doc/{id}` in case of explicit ids and `POST {index}/_doc`
  for auto-generated ids.

* The `GET|PUT _mapping` APIs support a query string parameter
  (`include_type_name`) which indicates whether the body should include
  a layer for the type name. It defaults to `true`. 7.x indices which
  don't have an explicit type will use the dummy type name `_doc`.

* The `_default_` mapping type is removed.

Elasticsearch 8.x::

* The `type` parameter is no longer supported in URLs.

* The `include_type_name` parameter defaults to `false`.

Elasticsearch 9.x::

* The `include_type_name` parameter is removed.

[float]
=== Migrating multi-type indices to single-type

The <<docs-reindex,Reindex API>> can be used to convert multi-type indices to
single-type indices. The following examples can be used in Elasticsearch 5.6
or Elasticsearch 6.x.  In 6.x, there is no need to specify
`index.mapping.single_type` as that is the default.

[float]
==== Index per document type

This first example splits our `twitter` index into a `tweets` index and a
`users` index:

[source,js]
----
PUT users
{
  "settings": {
    "index.mapping.single_type": true
  },
  "mappings": {
    "_doc": {
      "properties": {
        "name": {
          "type": "text"
        },
        "user_name": {
          "type": "keyword"
        },
        "email": {
          "type": "keyword"
        }
      }
    }
  }
}

PUT tweets
{
  "settings": {
    "index.mapping.single_type": true
  },
  "mappings": {
    "_doc": {
      "properties": {
        "content": {
          "type": "text"
        },
        "user_name": {
          "type": "keyword"
        },
        "tweeted_at": {
          "type": "date"
        }
      }
    }
  }
}

POST _reindex
{
  "source": {
    "index": "twitter",
    "type": "user"
  },
  "dest": {
    "index": "users"
  }
}

POST _reindex
{
  "source": {
    "index": "twitter",
    "type": "tweet"
  },
  "dest": {
    "index": "tweets"
  }
}
----
// NOTCONSOLE

[float]
==== Custom type field

This next example adds a custom `type` field and sets it to the value of the
original `_type`.  It also adds the type to the `_id` in case there are any
documents of different types which have conflicting IDs:

[source,js]
----
PUT new_twitter
{
  "mappings": {
    "_doc": {
      "properties": {
        "type": {
          "type": "keyword"
        },
        "name": {
          "type": "text"
        },
        "user_name": {
          "type": "keyword"
        },
        "email": {
          "type": "keyword"
        },
        "content": {
          "type": "text"
        },
        "tweeted_at": {
          "type": "date"
        }
      }
    }
  }
}


POST _reindex
{
  "source": {
    "index": "twitter"
  },
  "dest": {
    "index": "new_twitter"
  },
  "script": {
    "source": """
      ctx._source.type = ctx._type;
      ctx._id = ctx._type + '-' + ctx._id;
      ctx._type = '_doc';
    """
  }
}
----
// NOTCONSOLE

