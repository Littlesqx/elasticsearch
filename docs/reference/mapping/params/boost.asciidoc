[[mapping-boost]]
=== `boost`

单个字段可以自动_boosted_——在查询时更多地计入相关性分数，使用 `boost` 参数，如下所示：

[source,js]
--------------------------------------------------
PUT my_index
{
  "mappings": {
    "_doc": {
      "properties": {
        "title": {
          "type": "text",
          "boost": 2 <1>
        },
        "content": {
          "type": "text"
        }
      }
    }
  }
}
--------------------------------------------------
// CONSOLE

<1> `title` 字段上的匹配将具有两倍于`content`字段的匹配，其具有默认的 `boost` 为 `1.0` 。

注意：提升仅适用于 term 查询（前缀、范围和模糊查询不是_boosted_）。

你可以通过在查询中直接使用 boost 参数来实现相同的效果，例如以下查询（使用字段时间 boost）：

[source,js]
--------------------------------------------------
POST _search
{
    "query": {
        "match" : {
            "title": {
                "query": "quick brown fox"
            }
        }
    }
}
--------------------------------------------------
// CONSOLE

等价于：

[source,js]
--------------------------------------------------
POST _search
{
    "query": {
        "match" : {
            "title": {
                "query": "quick brown fox",
                "boost": 2
            }
        }
    }
}
--------------------------------------------------
// CONSOLE

使用 <<mapping-all-field,`_all`>> 字段中的值复制时，也会应用 boost。这意味着，当查询 `_all` 字段时，源自 `title` 字段的单词的得分将高于源自`content`字段的单词。此功能需要付出代价：使用字段 boost 时， `_all` 字段上的查询速度会变慢。

弃用[5.0.0, 不推荐使用索引时间 boost。相反，字段映射 boost 在查询时应用。对于在 5.0.0 之前创建的索引，仍将在索引时应用。]
[WARNING]
.为什么 索引时间 boosting 是一个坏主意
==================================================

我们建议不要使用索引时间 boosting，原因如下：

* 如果不重新索引所有文档，则无法更改索引时间的 `boost` 值。

* 每个查询都支持查询时间 boosting，从而实现相同的效果。不同之处在于无需重新索引即可调整 `boost` 值。

* 索引时间增强存储为 <<norms,`norm`>> 的一部分，它只有一个字节。这降低了场长归一化因子的分辨率，这可能导致较低质量的相关性计算。

==================================================
