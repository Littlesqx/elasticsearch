[[multi-fields]]
=== `fields`

为不同目的以不同方式索引相同字段通常很有用。这也是 _multi-fields_ 的目的。例如， `string` 字段可以映射为全文搜索的 `text` 字段，以及作为排序或聚合的 `keyword` 字段：

[source,js]
--------------------------------------------------
PUT my_index
{
  "mappings": {
    "_doc": {
      "properties": {
        "city": {
          "type": "text",
          "fields": {
            "raw": { <1>
              "type":  "keyword"
            }
          }
        }
      }
    }
  }
}

PUT my_index/_doc/1
{
  "city": "New York"
}

PUT my_index/_doc/2
{
  "city": "York"
}

GET my_index/_search
{
  "query": {
    "match": {
      "city": "york" <2>
    }
  },
  "sort": {
    "city.raw": "asc" <3>
  },
  "aggs": {
    "Cities": {
      "terms": {
        "field": "city.raw" <3>
      }
    }
  }
}
--------------------------------------------------
// CONSOLE
<1> `city.raw` 字段是 `city` 字段的 `keyword` 类型的版本。
<2> `city` 字段可以被用于全文搜索。
<3> `city.raw` 字段可以被用于排序和聚合。

NOTE: 多字段不会改变原始的 `_source` 字段。

TIP: 允许对同一索引中的同名字段设置不同的 `fields` 设置。新多字段可以通过 <<indices-put-mapping,PUT mapping API>> 被添加到已经存在的字段。

==== 具有多分析器的多字段

多字段的另一个用例是以不同方式分析相同字段以获得更好的相关性。例如，我们可以使用 <<analysis-standard-analyzer,`standard` 分析器>>索引一个字段，这会把文本分成单词；
相反， <<english-analyzer,`english` 分析器>>则将单词还原成根形式：

[source,js]
--------------------------------------------------
PUT my_index
{
  "mappings": {
    "_doc": {
      "properties": {
        "text": { <1>
          "type": "text",
          "fields": {
            "english": { <2>
              "type":     "text",
              "analyzer": "english"
            }
          }
        }
      }
    }
  }
}

PUT my_index/_doc/1
{ "text": "quick brown fox" } <3>

PUT my_index/_doc/2
{ "text": "quick brown foxes" } <3>

GET my_index/_search
{
  "query": {
    "multi_match": {
      "query": "quick brown foxes",
      "fields": [ <4>
        "text",
        "text.english"
      ],
      "type": "most_fields" <4>
    }
  }
}
--------------------------------------------------
// CONSOLE

<1> `text` 字段使用 `standard` 分析器。
<2> `text.english` 字段使用 `english` 分析器。
<3> 索引两个文档，一个使用 `fox` 而另一个使用 `foxes` 。
<4> 同时查询 `text` 和 `text.english` 字段，并结合分数。

The `text` field contains the term `fox` in the first document and `foxes` in
the second document.  The `text.english` field contains `fox` for both
documents, because `foxes` is stemmed to `fox`.

`text` 字段在第一个文档中包含术语 `fox` ，在第二个文档中包含 `foxes` 。 `text.english` 字段包含两个文件的 `foxes` ，因为 `foxes` 源自 `fox` 。

查询字符串也由 `standard` 分析器分析 `text` 字段，并由 `english` 分析器分析 `text.english` 字段。
词干字段允许查询 `foxes` 也匹配仅包含 `fox` 的文档。这允许我们尽可能匹配多一些文档。
通过查询未经过干扰的 `text` 字段，我们提高了与 `foxes` 完全匹配的文档的相关性得分。
