[[eager-global-ordinals]]
=== `eager_global_ordinals`

全局序数是 doc 值之上的数据结构，它维护字典顺序中每个唯一词项（term）的增量编号。每个词项（term）都有一个唯一的数字，词项（term）“A”的数量低于词项（term）“B”的数量。
全局序数仅受 <<keyword,`keyword`>> 和 <<text,`text`>> 字段的支持。在 `keyword` 字段中，它们默认可用，但 `text` 字段只能在 `fielddata` 及其所有相关包裹启用时使用它们。

Doc 值（和 fielddata）也有序数，这是特定的段（segment）和字段中所有词项（term）的唯一编号。通过提供段（segment）序数和全局序数之间的映射，全局序数建立在此之上，后者在整个分片中是唯一的。
鉴于特定字段的全局序数与所有 shard_ 的段（segment）相关联，只要一个新段（segment）可见，就需要完全重建它们。

全局序数用于使用段（segment）序数的功能，例如 <<search-aggregations-bucket-terms-aggregation,`terms` 聚合>>，以改善执行时间。
词项（term）聚合完全依赖于全局序数来在分片级别执行聚合，然后仅将最终减少阶段的全局序数转换为实际术语，其结合来自不同分片的结果。
全局序数的加载时间取决于字段中的词项（term）数，但通常它很低，因为源字段数据已经加载了。全局序数的内存开销很小，因为它被非常有效地压缩了。

默认情况下，全局序数在搜索时加载，如果你正在优化索引速度，这是正确的权衡。但是，如果你对搜索速度更感兴趣，那么在计划用于聚合词项（term）的字段上设置 `eager_global_ordinals：true` 会很有趣：

[source,js]
------------
PUT my_index/_mapping/_doc
{
  "properties": {
    "tags": {
      "type": "keyword",
      "eager_global_ordinals": true
    }
  }
}
------------
// CONSOLE
// TEST[s/^/PUT my_index\n/]

这会将成本从搜索时间转移到刷新时间。Elasticsearch 将确保在发布索引内容的更新之前构建全局序数。

你如果决定不再需要在此字段上运行 `terms` 聚合，那么可以随时禁用 `eager_global_ordinals`：

[source,js]
------------
PUT my_index/_mapping/_doc
{
  "properties": {
    "tags": {
      "type": "keyword",
      "eager_global_ordinals": false
    }
  }
}
------------
// CONSOLE
// TEST[continued]

