[[parent-join]]
=== `join` 数据类型

`join` 数据类型是一个在同一索引的文档中创建父/子关系的特殊字段。
`relations` 部分定义了文档中的一组可能的关系，每个关系是父名称和子名称。父/子关系可以定义如下：

[source,js]
--------------------------------------------------
PUT my_index
{
  "mappings": {
    "_doc": {
      "properties": {
        "my_join_field": { <1>
          "type": "join",
          "relations": {
            "question": "answer" <2>
          }
        }
      }
    }
  }
}
--------------------------------------------------
// CONSOLE

<1> 字段的名称。
<2> 定义一个单独的关系，其中 `question` 是 `answer` 的父级。

要使用 join 索引文档，必须在 `source` 中提供关系的名称和文档的可选父级。

例如，以下示例在 `question` 上下文中创建两个 `parent` 文档：

[source,js]
--------------------------------------------------
PUT my_index/_doc/1?refresh
{
  "text": "This is a question",
  "my_join_field": {
    "name": "question" <1>
  }
}

PUT my_index/_doc/2?refresh
{
  "text": "This is a another question",
  "my_join_field": {
    "name": "question"
  }
}
--------------------------------------------------
// CONSOLE
// TEST[continued]

<1> 该文档是一个 `question` 文档。

索引父文档时，你可以选择仅将关系的名称指定为快捷方式，而不是将其封装在普通对象表示法中：

[source,js]
--------------------------------------------------
PUT my_index/_doc/1?refresh
{
  "text": "This is a question",
  "my_join_field": "question" <1>
}

PUT my_index/_doc/2?refresh
{
  "text": "This is another question",
  "my_join_field": "question"
}
--------------------------------------------------
// CONSOLE
// TEST[continued]

<1> 父文档的简单表示法只使用关系名称。

索引子项时，必须在 `_source` 中添加关系的名称以及文档的父 ID。

警告：需要在同一分片中索引父级的谱系，因此必须始终使用其较大的父 ID 来路由子文档。

例如，以下示例显示了如何索引两个 `child` 文档：

[source,js]
--------------------------------------------------
PUT my_index/_doc/3?routing=1&refresh <1>
{
  "text": "This is an answer",
  "my_join_field": {
    "name": "answer", <2>
    "parent": "1" <3>
  }
}

PUT my_index/_doc/4?routing=1&refresh
{
  "text": "This is another answer",
  "my_join_field": {
    "name": "answer",
    "parent": "1"
  }
}
--------------------------------------------------
// CONSOLE
// TEST[continued]

<1> 路由值是必需的，因为父文档和子文档必须在同一个分片上建立索引。
<2> `answer` 是此文档的 join 名称。
<3> 此子文档的父 ID。

==== Parent-join 和性能

join 字段不应该像关系数据库中的连接一样使用。在 Elasticsearch 中，良好性能的关键是将数据去规范化为文档。
每个 join 字段， `has_child` 或 `has_parent` 查询都会对查询性能产生重大影响。


连接字段有意义的唯一情况是，如果你的数据包含一对多关系，其中一个实体明显超过另一个实体。
产品的和这些产品的报价是这种情况的一个例子。
如果产品报价数量明显多于产品数量，则将产品建模为父文档并将产品建模为子文档是有意义的。

==== Parent-join 限制

* 每个索引只允许一个 `join` 字段映射。
* 父文档和子文档必须在同一个分片上编制索引。
  这意味着当<<docs-get,获取>> 、<<docs-delete,删除>>或<<docs-update,更新>>子文档时，需要提供相同的 `routing` 值。
* 元素可以有多个子元素但只有一个父元素。
* 可以向现有的 `join` 字段添加新关系。
* 也可以将子项添加到现有元素，但仅当该元素已经是父元素时才可以。

==== 使用 parent-join 查询

parent-join 创建一个字段来索引文档中关系的名称（ `my_parent` 、 `my_child` ...）。

它还为每个父/子关系创建一个字段。该字段的名称是 `join` 字段的名称，后跟 `＃` 和关系中父项的名称。
因此，例如对于 `my_parent` => [`my_child`,`another_child`] 关系， `join` 字段创建一个名为 `my_join_field＃my_parent` 的附加字段。

如果文档是子文档（ `my_child` 或 `another_child` ），则该字段包含文档链接到的父文档 `_id` ，
而如果文档是父文档（ `my_parent` ），则包含文档的 `_id` 。

搜索包含 `join` 字段的索引时，始终在搜索响应中返回这两个字段：

[source,js]
--------------------------
GET my_index/_search
{
  "query": {
    "match_all": {}
  },
  "sort": ["_id"]
}
--------------------------
// CONSOLE
// TEST[continued]

将返回：

[source,js]
--------------------------------------------------
{
    ...,
    "hits": {
        "total": 4,
        "max_score": null,
        "hits": [
            {
                "_index": "my_index",
                "_type": "_doc",
                "_id": "1",
                "_score": null,
                "_source": {
                    "text": "This is a question",
                    "my_join_field": "question" <1>
                },
                "sort": [
                    "1"
                ]
            },
            {
                "_index": "my_index",
                "_type": "_doc",
                "_id": "2",
                "_score": null,
                "_source": {
                    "text": "This is another question",
                    "my_join_field": "question" <2>
                },
                "sort": [
                    "2"
                ]
            },
            {
                "_index": "my_index",
                "_type": "_doc",
                "_id": "3",
                "_score": null,
                "_routing": "1",
                "_source": {
                    "text": "This is an answer",
                    "my_join_field": {
                        "name": "answer", <3>
                        "parent": "1"  <4>
                    }
                },
                "sort": [
                    "3"
                ]
            },
            {
                "_index": "my_index",
                "_type": "_doc",
                "_id": "4",
                "_score": null,
                "_routing": "1",
                "_source": {
                    "text": "This is another answer",
                    "my_join_field": {
                        "name": "answer",
                        "parent": "1"
                    }
                },
                "sort": [
                    "4"
                ]
            }
        ]
    }
}
--------------------------------------------------
// TESTRESPONSE[s/\.\.\./"timed_out": false, "took": $body.took, "_shards": $body._shards/]

<1> 该文档属于 `question` join。
<2> 该文档属于 `question` join。
<3> 该文档属于 `answer` join。
<4> 子文档的链接父 ID。

==== Parent-join 查询和聚合

参考 <<query-dsl-has-child-query,`has_child`>> 和 <<query-dsl-has-parent-query,`has_parent`>> 查询，
<<search-aggregations-bucket-children-aggregation,`children`>> 聚合和 <<parent-child-inner-hits,inner hits>> 以查阅更多信息。

可以在聚合和脚本中访问 `join` 字段的值，可以使用 <<query-dsl-parent-id-query,`parent_id` query>> 查询：

[source,js]
--------------------------
GET my_index/_search
{
  "query": {
    "parent_id": { <1>
      "type": "answer",
      "id": "1"
    }
  },
  "aggs": {
    "parents": {
      "terms": {
        "field": "my_join_field#question", <2>
        "size": 10
      }
    }
  },
  "script_fields": {
    "parent": {
      "script": {
         "source": "doc['my_join_field#question']" <3>
      }
    }
  }
}
--------------------------
// CONSOLE
// TEST[continued]

<1> 查询 `parent id` 字段（另见 <<query-dsl-has-parent-query,`has_parent` query>> 和 <<query-dsl-has-child-query,`has_child` query>>）。
<2> 在 `parent id` 字段上聚合（另见 <<search-aggregations-bucket-children-aggregation,`children`>> 聚合）。
<3> 访问脚本中的父 ID 字段。


==== 全局序数（Global ordinals）

`join` 字段使用<<eager-global-ordinals,全局序数（Global ordinals）>>来加速 join。
在对分片进行任何更改后，需要重建全局序数。父级 ID 值存储在分片中越多，重建 `join` 字段的全局序数所需的时间越长。

默认情况下，全局序数是急切建立的：如果索引已更改，则 `join` 字段的全局序号将作为刷新的一部分重建。
这可以为刷新增加大量时间。但是大多数情况下这是正确的权衡，否则在使用第一个父连接查询或聚合时会重建全局序数。
这可能会为您的用户带来显着的延迟峰值，并且通常情况会更糟，因为当发生许多写操作时，可以在单个刷新间隔内尝试重建 `join` 字段的多个全局序数。

当不经常使用 `join` 字段并经常进行写入操作时，禁用预先加载可能是有意义的：

[source,js]
--------------------------------------------------
PUT my_index
{
  "mappings": {
    "_doc": {
      "properties": {
        "my_join_field": {
          "type": "join",
          "relations": {
             "question": "answer"
          },
          "eager_global_ordinals": false
        }
      }
    }
  }
}
--------------------------------------------------
// CONSOLE

可以按父关系检查全局序数使用的堆量，如下所示：

[source,sh]
--------------------------------------------------
# Per-index
GET _stats/fielddata?human&fields=my_join_field#question

# Per-node per-index
GET _nodes/stats/indices/fielddata?human&fields=my_join_field#question
--------------------------------------------------
// CONSOLE
// TEST[continued]

==== 父项的多子项

也可以为单个父项定义多个子项：

[source,js]
--------------------------------------------------
PUT my_index
{
  "mappings": {
    "_doc": {
      "properties": {
        "my_join_field": {
          "type": "join",
          "relations": {
            "question": ["answer", "comment"]  <1>
          }
        }
      }
    }
  }
}
--------------------------------------------------
// CONSOLE

<1> `question` 是 `answer` 和 `comment` 的父级。

==== parent join 的多层级

警告：不建议使用多级关系来复制关系模型。
每个级别的关系在查询时在内存和计算方面增加了开销。如果你担心性能，则应该对数据进行去规范化。

parent/child 的多层级：

[source,js]
--------------------------------------------------
PUT my_index
{
  "mappings": {
    "_doc": {
      "properties": {
        "my_join_field": {
          "type": "join",
          "relations": {
            "question": ["answer", "comment"],  <1>
            "answer": "vote" <2>
          }
        }
      }
    }
  }
}
--------------------------------------------------
// CONSOLE

<1> `question` 是 `answer` 和 `comment` 的父级。
<2> `answer` 是 `vote` 的父级。

上面的映射可表示为以下的树：

                         question
                          /    \
                         /      \
                      comment  answer
                                 |
                                 |
                                vote

索引一个大的子文档需要一个等于 grand-parent（该 lineage 的更大父级）的 `routing` 值：


[source,js]
--------------------------------------------------
PUT my_index/_doc/3?routing=1&refresh <1>
{
  "text": "This is a vote",
  "my_join_field": {
    "name": "vote",
    "parent": "2" <2>
  }
}
--------------------------------------------------
// CONSOLE
// TEST[continued]

<1> 此子文档必须位于与其父父级（grand-parent）和父级相同的分片上。
<2> 此文档的父 ID（必须指向 `answer` 文档）。