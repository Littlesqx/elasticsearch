[[array]]
=== 数组类型

在 Elasticsearch，没有专门的数组类型。任何字段默认都可以包含零个或更多个值，
但是，一个数据中的所有值必须是相同的数据类型。例如：

* 字符串数组: [ `"one"`, `"two"` ]
* 整型数组: [ `1`, `2` ]
* 数组元素也是数组: [ `1`, [ `2`, `3` ]]，并且它等于 [ `1`, `2`, `3` ]
* 对象数组: [ `{ "name": "Mary", "age": 12 }`, `{ "name": "John", "age": 10 }`]

对象数组
[NOTE]
====================================================

对象数组不会像你期望的那样工作：
你不能独立于数组中其他对象元素而查找每一个对象。
如果你需要达到这个目的，那么你应该使用 <<nested,`nested`>> 数据，
而不是 <<object,`object`>> 类型。

在 <<nested>> 阐述了更多细节。
====================================================

当动态添加一个字段的时候，数组中的第一个元素决定了字段类型。
所有后续元素必须具有相同的数据类型，或者至少可能被 <<coerce,强制（coerce）>> 转换为相同的数据类型。

数组不支持混合的数据类型：[ `10`, `"some string"` ]

一个数组可能包含 `null` 值，或者它会被替换为配置的 <<null-value,`null_value`>> 或完全跳过。
一个空数组 `[]` 会被视为缺失字段——没有值的字段

在文档中使用数组，不需要预先配置，它们是开箱即用的：


[source,js]
--------------------------------------------------
PUT my_index/_doc/1
{
  "message": "some arrays in this document...",
  "tags":  [ "elasticsearch", "wow" ], <1>
  "lists": [ <2>
    {
      "name": "prog_list",
      "description": "programming list"
    },
    {
      "name": "cool_list",
      "description": "cool stuff list"
    }
  ]
}

PUT my_index/_doc/2 <3>
{
  "message": "no arrays in this document...",
  "tags":  "elasticsearch",
  "lists": {
    "name": "prog_list",
    "description": "programming list"
  }
}

GET my_index/_search
{
  "query": {
    "match": {
      "tags": "elasticsearch" <4>
    }
  }
}
--------------------------------------------------
// CONSOLE
<1> The `tags` field is dynamically added as a `string` field.
<2> The `lists` field is dynamically added as an `object` field.
<3> The second document contains no arrays, but can be indexed into the same fields.
<4> The query looks for `elasticsearch` in the `tags` field, and matches both documents.

.Multi-value fields and the inverted index
****************************************************

The fact that all field types support multi-value fields out of the box is a
consequence of the origins of Lucene.  Lucene was designed to be a full text
search engine.  In order to be able to search for individual words within a
big block of text, Lucene tokenizes the text into individual terms, and
adds each term to the inverted index separately.

This means that even a simple text field must be able to support multiple
values by default.  When other datatypes were added, such as numbers and
dates, they used the same data structure as strings, and so got multi-values
for free.

****************************************************

