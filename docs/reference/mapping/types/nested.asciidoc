[[nested]]
=== 嵌套数据类型

嵌套类型（`nested` datatype）是 <<object,`object`>> 类型的一个特殊类型，
它允许了数组和对象彼此之间独立地被索引和查询。

==== 数组和对象如何被展平

内部 <<object,`object` 字段>>的数组不能按照你期望的方式工作。
Lucene 没有内部对象的概念，因此 Elasticsearch 将对象层次结构展平为一个简单的字段名称和值的列表。

例如下面的文档：

[source,js]
--------------------------------------------------
PUT my_index/_doc/1
{
  "group" : "fans",
  "user" : [ <1>
    {
      "first" : "John",
      "last" :  "Smith"
    },
    {
      "first" : "Alice",
      "last" :  "White"
    }
  ]
}
--------------------------------------------------
// CONSOLE
<1> `user` 字段被以 `object` 类型字段动态地添加。

它会在内部被转换为像这样的文档：

[source,js]
--------------------------------------------------
{
  "group" :        "fans",
  "user.first" : [ "alice", "john" ],
  "user.last" :  [ "smith", "white" ]
}
--------------------------------------------------
// NOTCONSOLE

`user.first` 和 `user.last` 字段被展平为多值字段，
并且 `alice` 和 `white` 之间的联系丢失了。
这个文档会错误地匹配 `alice AND smith` 的查询

[source,js]
--------------------------------------------------
GET my_index/_search
{
  "query": {
    "bool": {
      "must": [
        { "match": { "user.first": "Alice" }},
        { "match": { "user.last":  "Smith" }}
      ]
    }
  }
}
--------------------------------------------------
// CONSOLE
// TEST[continued]

==== 为对象数组使用 `nested` 字段

如果你需要索引对象数组和维护数组中每个对象的独立性，你需要使用 `nested` 类型，而不是 <<object,`object`>> 类型。
在内部，嵌套对象将数组中的每个对象索引为一个单独的隐藏文档，这意味着每个嵌套对象都可以独立于其他对象，
使用 <<query-dsl-nested-query,`nested` query>> 进行查询：

[source,js]
--------------------------------------------------
PUT my_index
{
  "mappings": {
    "_doc": {
      "properties": {
        "user": {
          "type": "nested" <1>
        }
      }
    }
  }
}

PUT my_index/_doc/1
{
  "group" : "fans",
  "user" : [
    {
      "first" : "John",
      "last" :  "Smith"
    },
    {
      "first" : "Alice",
      "last" :  "White"
    }
  ]
}

GET my_index/_search
{
  "query": {
    "nested": {
      "path": "user",
      "query": {
        "bool": {
          "must": [
            { "match": { "user.first": "Alice" }},
            { "match": { "user.last":  "Smith" }} <2>
          ]
        }
      }
    }
  }
}

GET my_index/_search
{
  "query": {
    "nested": {
      "path": "user",
      "query": {
        "bool": {
          "must": [
            { "match": { "user.first": "Alice" }},
            { "match": { "user.last":  "White" }} <3>
          ]
        }
      },
      "inner_hits": { <4>
        "highlight": {
          "fields": {
            "user.first": {}
          }
        }
      }
    }
  }
}
--------------------------------------------------
// CONSOLE
<1> `user` 字段被以 `nested` 类型映射，而不是 `object` 类型。
<2> 查询不会匹配，因为 `Alice` 和 `Smith` 不在相同的嵌套对象中。
<3> 查询会匹配，因为 `Alice` 和 `White` 在相同的嵌套对象中。 
<4> `inner_hits` 允许我们高亮匹配的嵌套文档。

嵌套文档可以被：

* 使用 <<query-dsl-nested-query,`nested`>> 查询。
* 使用 <<search-aggregations-bucket-nested-aggregation,`nested`>> 分析和 <<search-aggregations-bucket-reverse-nested-aggregation, `reverse_nested`>> 聚合。
* 使用 <<nested-sorting,nested sorting>> 排序。
* 使用 <<nested-inner-hits,nested inner hits>> 复取和高亮。


[[nested-params]]
==== `nested` 字段的参数

`nested` 字段接受下面的参数：

[horizontal]
<<dynamic,`dynamic`>>::

    新 `properties` 是否应该被动态添加到已存在的嵌套对象中。接受 `true` （默认），`false` 和 `strict` 。

<<properties,`properties`>>::

    嵌套对象内部的字段，可以是 任意的 <<mapping-types,数据类型>>，包括 `nested` 。
    新 `properties` 可以被添加到已存在的嵌套对象。


[IMPORTANT]
=============================================

嵌套文档因为是以单独文档被索引，
所以仅仅可以在嵌套查询（`nested`/`reverse_nested`, 或 <<nested-inner-hits,nested inner hits>>）内被接受。

例如，如果嵌套文档中的字符串字段的 <<index-options,`index_options`>> 设置为 `offsets` 以允许在高亮阶段 postings 的使用，
在主要的高亮阶段，这些 `offsets` 不可用。相反，高亮需要通过 <<nested-inner-hits,nested inner hits>> 进行。
=============================================


==== 限制 `nested` 字段的数量

索引一个包含 100 个 nested 字段的文档实际上是索引 101 个文档，因为每个嵌套文档都作为一个独立文档来索引。
为了防止过度定义嵌套字段的数量，每个索引可以定义的嵌套字段被限制在 50 个。参考 <<mapping-limit-settings>> 。
