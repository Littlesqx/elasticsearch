[[dynamic-templates]]
=== 动态模板

动态模板允许你定义可应用于动态添加字段的自定义映射，具体取决于：

* Elasticsearch 的<<dynamic-mapping,数据类型>>，通过 <<match-mapping-type,`match_mapping_type`>> 。
* 字段名，通过 <<match-unmatch,`match` 和 `unmatch`>> 或 <<match-pattern,`match_pattern`>> 。
* 字段的完整虚线路径，使用 << path-match-unmatch,`path_match` 和 `path_unmatch`>> 。

原始字段名 `{name}` 和检测到的数据类型 `{dynamic_type`} <<template-variables,模板变量>> 可以在映射规范中用作占位符。

重要：仅当字段包含具体值时才会添加动态字段映射 - 不是 `null` 或空数组。
这意味着如果在 `dynamic_template` 中使用 `null_value` 选项，它将仅在具有该字段的具体值的第一个文档被索引之后应用。

动态模板被指定为命名对象的数组：

[source,js]
--------------------------------------------------
  "dynamic_templates": [
    {
      "my_template_name": { <1>
        ...  match conditions ... <2>
        "mapping": { ... } <3>
      }
    },
    ...
  ]
--------------------------------------------------
// NOTCONSOLE
<1> 模板名称可以是任何字符串值。
<2> 匹配条件可包括以下任何一项： `match_mapping_type` 、 `match` 、 `match_pattern` 、 `unmatch` 、 `path_match` 、 `path_unmatch` 。
<3> 匹配字段应使用的映射。

模板按顺序处理 - 第一个匹配的模板获胜。通过 <<indices-put-mapping,put mapping>> API 放置新的动态模板时，将覆盖所有现有模板。这允许动态模板在最初添加后重新排序或删除。

[[match-mapping-type]]
==== `match_mapping_type`

`match_mapping_type` 是通过 json 解析器检测到的数据类型。自从 JSON 不允许区分 `long` 和 `integer` 、 `double` 和 `float` ， 它会总是选择更大的数据类型，
即整形的 `long` 和 浮点型的 `double` 。 

以下数据类型可能会被自动检测：

 - `boolean` ，当检测到 `true` 或 `false` 。
 - `date` ，当 <<date-detection,日期检测>> 启用，并且字符串值被发现匹配上任意配置好的格式。
 - `double` ，有小数部分的数字。
 - `long` ，没有小数部分的数字。
 - `object` ，对象，也叫散列（hashes）。
 - `string` ，字符串。

`*` 可用于匹配所有数据类型。

例如，我们如果想将所有整数字段映射为 `integer` 而不是 `long` ，并将所有 `string` 字段映射为 `text` 和 `keyword` ，可以使用以下模板：

[source,js]
--------------------------------------------------
PUT my_index
{
  "mappings": {
    "_doc": {
      "dynamic_templates": [
        {
          "integers": {
            "match_mapping_type": "long",
            "mapping": {
              "type": "integer"
            }
          }
        },
        {
          "strings": {
            "match_mapping_type": "string",
            "mapping": {
              "type": "text",
              "fields": {
                "raw": {
                  "type":  "keyword",
                  "ignore_above": 256
                }
              }
            }
          }
        }
      ]
    }
  }
}

PUT my_index/_doc/1
{
  "my_integer": 5, <1>
  "my_string": "Some string" <2>
}
--------------------------------------------------
// CONSOLE
<1> `my_integer` 字段被映射为 `integer` 。
<2> `my_string` 字段被映射为 `text` ，并带有 `keyword` <<multi-fields,子字段>>。


[[match-unmatch]]
==== `match` 和 `unmatch`

`match` 参数使用模式匹配字段名称，而 `unmatch` 使用模式排除匹配 `match` 的字段。

下面的示例匹配名称以 `long_` 开头的所有 `string` 字段（除了那些以 `_text` 结尾的字段）并将它们映射为 `long` 字段：

[source,js]
--------------------------------------------------
PUT my_index
{
  "mappings": {
    "_doc": {
      "dynamic_templates": [
        {
          "longs_as_strings": {
            "match_mapping_type": "string",
            "match":   "long_*",
            "unmatch": "*_text",
            "mapping": {
              "type": "long"
            }
          }
        }
      ]
    }
  }
}

PUT my_index/_doc/1
{
  "long_num": "5", <1>
  "long_text": "foo" <2>
}
--------------------------------------------------
// CONSOLE
<1> `long_num` 字段被映射为 `long` 。
<2> `long_text` 字段使用默认的 `string` 映射。

[[match-pattern]]
==== `match_pattern`

`match_pattern` 参数调整 `match` 参数的行为，使其支持字段名称上的完整 Java 正则表达式匹配，而不是简单的通配符，例如：

[source,js]
--------------------------------------------------
  "match_pattern": "regex",
  "match": "^profit_\d+$"
--------------------------------------------------
// NOTCONSOLE

[[path-match-unmatch]]
==== `path_match` 和 `path_unmatch`

`path_match` 和 `path_unmatch` 参数的工作方式与 `match` 和 `unmatch` 相同，但是它们在字段的完整点线路径上操作，而不仅仅是最终名称，
例如： `some_object`.*.`some_field` 。

此示例将 `name` 对象中的任何字段的值复制到顶级 `full_name` 字段，但 `middle` 字段除外：

[source,js]
--------------------------------------------------
PUT my_index
{
  "mappings": {
    "_doc": {
      "dynamic_templates": [
        {
          "full_name": {
            "path_match":   "name.*",
            "path_unmatch": "*.middle",
            "mapping": {
              "type":       "text",
              "copy_to":    "full_name"
            }
          }
        }
      ]
    }
  }
}

PUT my_index/_doc/1
{
  "name": {
    "first":  "Alice",
    "middle": "Mary",
    "last":   "White"
  }
}
--------------------------------------------------
// CONSOLE

[[template-variables]]
==== `{name}` 和 `{dynamic_type}`                       

`{name}` 和 `{dynamic_type}` 占位符在 `mapping` 中被替换为字段名称和检测到的动态类型。
以下示例将所有字符串字段设置为使用与该字段同名的 <<analyzer,`analyzer`>> ，并为所有非字符串字段禁用 <<doc-values,`doc_values`>> ：

[source,js]
--------------------------------------------------
PUT my_index
{
  "mappings": {
    "_doc": {
      "dynamic_templates": [
        {
          "named_analyzers": {
            "match_mapping_type": "string",
            "match": "*",
            "mapping": {
              "type": "text",
              "analyzer": "{name}"
            }
          }
        },
        {
          "no_doc_values": {
            "match_mapping_type":"*",
            "mapping": {
              "type": "{dynamic_type}",
              "doc_values": false
            }
          }
        }
      ]
    }
  }
}

PUT my_index/_doc/1
{
  "english": "Some English text", <1>
  "count":   5 <2>
}
--------------------------------------------------
// CONSOLE
<1> `english` 字段被映射为 `string` 字段，使用 `english` 分析器。
<2> `count` 字段被映射为 `long` 字段，并且禁用 `doc_values` 。

[[template-examples]]
==== Template 例子

以下是一些可能有用的动态模板示例：

===== 结构化搜索

默认情况下，Elasticsearch 会将字符串字段映射为带有子 `keyword` 字段的 `text` 字段。
但是，如果只是对结构化内容编制索引而对全文搜索不感兴趣，则可以使 Elasticsearch 仅将字段映射为 `keyword` 。
请注意，这意味着为了搜索这些字段，必须搜索与索引完全相同的值。

[source,js]
--------------------------------------------------
PUT my_index
{
  "mappings": {
    "_doc": {
      "dynamic_templates": [
        {
          "strings_as_keywords": {
            "match_mapping_type": "string",
            "mapping": {
              "type": "keyword"
            }
          }
        }
      ]
    }
  }
}
--------------------------------------------------
// CONSOLE

===== `text`- 仅仅为字符串映射

与前面的示例相反，如果你在字符串字段中唯一关心的是全文搜索，并且如果您不打算在字符串字段上运行聚合，排序或精确搜索，
那么你可以告诉 Elasticsearch 仅将其映射为文本字段（这是 5.0 之前的默认行为）：

[source,js]
--------------------------------------------------
PUT my_index
{
  "mappings": {
    "_doc": {
      "dynamic_templates": [
        {
          "strings_as_text": {
            "match_mapping_type": "string",
            "mapping": {
              "type": "text"
            }
          }
        }
      ]
    }
  }
}
--------------------------------------------------
// CONSOLE

===== 禁用规范

规范是指数时间评分因子。如果不关心评分，例如，如果从未按分数对文档进行排序，则可以禁用在索引中存储这些评分因子并节省一些空间。

[source,js]
--------------------------------------------------
PUT my_index
{
  "mappings": {
    "_doc": {
      "dynamic_templates": [
        {
          "strings_as_keywords": {
            "match_mapping_type": "string",
            "mapping": {
              "type": "text",
              "norms": false,
              "fields": {
                "keyword": {
                  "type": "keyword",
                  "ignore_above": 256
                }
              }
            }
          }
        }
      ]
    }
  }
}
--------------------------------------------------
// CONSOLE

子 `keyword` 字段出现在此模板中，以与动态映射的默认规则一致。
当然，如果你不需要它们（因为不需要在此字段上执行精确搜索或聚合），则可以按照上一节中的说明将其删除。


===== 时间序列

使用 Elasticsearch 进行时间序列分析时，通常会有许多数字字段，你可能经常聚合但从不过滤它们。 在这种情况下，可以禁用这些字段的索引以节省磁盘空间，也可以获得一些索引速度：

[source,js]
--------------------------------------------------
PUT my_index
{
  "mappings": {
    "_doc": {
      "dynamic_templates": [
        {
          "unindexed_longs": {
            "match_mapping_type": "long",
            "mapping": {
              "type": "long",
              "index": false
            }
          }
        },
        {
          "unindexed_doubles": {
            "match_mapping_type": "double",
            "mapping": {
              "type": "float", <1>
              "index": false
            }
          }
        }
      ]
    }
  }
}
--------------------------------------------------
// CONSOLE
<1> 与默认的动态映射规则一样，双精度映射为浮点数，浮点数通常足够准确，但需要一半的磁盘空间。

