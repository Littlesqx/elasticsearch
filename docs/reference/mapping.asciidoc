[[mapping]]
= 映射

[partintro]
--

映射（Mapping）是定义一个文档及其包含的字段如何被存储和索引的过程。例如，可以使用映射定义：

* 哪些字符串类型字段应该被视为全文类型字段。
* 哪些字段含有数字（numbers）、日期（dates）或地理位置（geolocations）。
* 文档中所有字段的值是否应该被索引到 catch-all 字段（<<mapping-all-field,`_all`>>）中。
* 日期的<<mapping-date-format,格式>>。
* 自定义规则<<dynamic-mapping,控制动态添加字段>>的映射。

[float]
[[mapping-type]]
== 映射类型

每个索引都有一个映射类型（Mapping-type），用于确定文档将如何被索引。

deprecated[6.0.0,参考 <<removal-of-types>>].

映射类型有:

<<mapping-fields,元字段>>::

元字段（Meta-fields）用于自定义文档元数据关联的处理方式。
元字段的例子包括文档的 <<mapping-index-field,`_index`>>，<<mapping-type-field,`_type`>>,
<<mapping-id-field,`_id`>> 和 <<mapping-source-field,`_source`>> 字段。

<<mapping-types,字段>> 或属性::

一个映射类型包含了与文档相关的字段或属性（properties）。


[float]
== 字段的数据类型

每个字段都有数据类型 type，它可以是：

* 简单类型，例如： <<text,`text`>>，<<keyword,`keyword`>>，<<date,`date`>>，<<number,`long`>>，
  <<number,`double`>>，<<boolean,`boolean`>> 或 <<ip,`ip`>>。
* 支持 JSON 分层特性的类型，例如：
  <<object,`object`>> 或 <<nested,`nested`>>。
* 或者一些专业的类型，例如： <<geo-point,`geo_point`>>，
  <<geo-shape,`geo_shape`>>， 或 <<search-suggesters-completion,`completion`>>。

为了达到不同的目的，以不同的方式索引相同的字段通常是有用的。
例如，字符串（string）字段可以被<<mapping-index,索引>>为用于全文搜索的文本（text）字段，并作为用于排序或聚合的关键字字段。
或者，可以使用<<analysis-standard-analyzer,标准分析器>>，<<analysis-standard-analyzer,英文分析器>>和<<french-analyzer,法语分析器>>等对字符串（string）字段进行索引。

这是多字段（multi-fields）的目的，而大多数数据类型可通过 <<multi-fields>> 参数支持多字段。

[[mapping-limit-settings]]
[float]
=== 防止映射爆炸的配置

在一个索引中定义太多字段可能会导致映射爆炸，进而导致内存泄露错误和难以
恢复的场景。这个问题可能比预期的更普遍。例如，考虑一种情况，每个被插入的文档都引入了新字段。
这在动态映射中很常见。每当一个文档包含新字段时，这些字段最终都将会在索引映射中。
对于少量的数据可不必担心，但随着映射增长它将会成为一个问题。
为了防止不好的文档造成映射爆炸，接下来的设置允许你限制字段映射（可以手动或动态创建）的数量：

`index.mapping.total_fields.limit`::
    索引中字段的最大数目。默认为 1000。

`index.mapping.depth.limit`::
    索引中字段的最大深度，即内部对象的数目。例如，如果所有字段都定义在根对象级别，那么字段深度为 1，而如果
    存在一个对象映射，那么字段深度为 2，以此类推。默认值为 20。

`index.mapping.nested_fields.limit`::
    索引中嵌套（nested）字段的最大数目，默认为 50。
    索引一个具有 100 个嵌套字段的文档实际上索引了 101 个文档，
    因为每个嵌套文档会作为一个分离的隐藏文档而被索引。


[float]
== 动态映射

字段和映射类型在使用前不需要被定义。
感谢动态映射，仅仅通过索引文档，新字段名会被自动添加。
新字段可以被添加到顶层映射类型，也可以添加到到内部的<<object,`对象字段`>>和<<nested,`嵌套字段`>>。

<<dynamic-mapping,动态类型>>规则可以设置到新字段使用的自定义映射

[float]
== 显式映射

相比于 Elasticsearch 猜，你是更了解你自己的数据的，所以尽管动态映射对于工作是有用的，在某些时候
你也需要指定显示映射。

你可以在<<indices-create-index,创建索引>>的时候创建字段映射，
并且你可以通过 <<indices-put-mapping,PUT mapping API>> 添加字段到现有的索引中。

[float]
== 更新现有的字段映射

除了文档记录之外，现有的字段映射不能被更新。更改映射意味着使已被索引的文档失效。
相反，你应该创建一个具有正确类型的新索引，并且<<docs-reindex,重新索引>>你的数据到该索引中。

[float]
== 映射例子

一个映射可以在创建索引时被指定：

[source,js]
---------------------------------------
PUT my_index <1>
{
  "mappings": {
    "doc": { <2>
      "properties": { <3>
        "title":    { "type": "text"  }, <4>
        "name":     { "type": "text"  }, <4>
        "age":      { "type": "integer" },  <4>
        "created":  {
          "type":   "date", <4>
          "format": "strict_date_optional_time||epoch_millis"
        }
      }
    }
  }
}
---------------------------------------
// CONSOLE
<1> 创建一个名为 `my_index` 的索引。
<2> 增加名为 `doc` 的映射。
<3> 指定字段或属性。
<4> 为每个字段指定数据类型和映射。


--

include::mapping/removal_of_types.asciidoc[]

include::mapping/types.asciidoc[]

include::mapping/fields.asciidoc[]

include::mapping/params.asciidoc[]

include::mapping/dynamic-mapping.asciidoc[]
